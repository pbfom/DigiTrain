import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_flush_callback,
  add_location,
  add_render_callback,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  bind,
  binding_callbacks,
  bubble,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  claim_text,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  noop,
  run_all,
  safe_not_equal,
  select_option,
  select_value,
  set_data_dev,
  set_input_value,
  set_style,
  space,
  svg_element,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_each_argument,
  validate_slots
} from "./chunk-NJX55KFT.js";
import "./chunk-T2T6Q22Z.js";

// node_modules/svelte-datatables-net/dist/functionSearch.js
var functionSearch = function(parData, parSearchString, parSearchableColumns) {
  const arraySearchable = parData.map((currentData) => {
    if (parSearchableColumns === void 0) {
      return {
        objectData: currentData,
        stringSearchable: ""
      };
    }
    const arraySearchablesBeforeJoin = parSearchableColumns.map((current) => {
      return currentData[current];
    });
    return {
      objectData: currentData,
      stringSearchable: arraySearchablesBeforeJoin.join(" ").toLowerCase()
    };
  });
  const arrayFilteredSearchable = arraySearchable.filter((current) => current.stringSearchable.includes(parSearchString.toLocaleLowerCase()));
  return arrayFilteredSearchable.map((current) => current.objectData);
};

// node_modules/svelte-datatables-net/dist/Engine.svelte
function create_fragment(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Engine", slots, []);
  let { propDatatable } = $$props;
  $$self.$$.on_mount.push(function() {
    if (propDatatable === void 0 && !("propDatatable" in $$props || $$self.$$.bound[$$self.$$.props["propDatatable"]])) {
      console.warn("<Engine> was created without expected prop 'propDatatable'");
    }
  });
  const writable_props = ["propDatatable"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Engine> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("propDatatable" in $$props2)
      $$invalidate(0, propDatatable = $$props2.propDatatable);
  };
  $$self.$capture_state = () => ({ functionSearch, propDatatable });
  $$self.$inject_state = ($$props2) => {
    if ("propDatatable" in $$props2)
      $$invalidate(0, propDatatable = $$props2.propDatatable);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*propDatatable*/
    1) {
      $: {
        $$invalidate(0, propDatatable.arraySorted = propDatatable.arrayRawData.sort(propDatatable.functionSort), propDatatable);
        $$invalidate(0, propDatatable.arraySearched = functionSearch(propDatatable.arraySorted, propDatatable.stringSearchString, propDatatable.arraySearchableColumns), propDatatable);
        $$invalidate(0, propDatatable.arrayData = propDatatable.arraySearched.slice(propDatatable.numberFirstRow, propDatatable.numberLastRow), propDatatable);
      }
    }
    if ($$self.$$.dirty & /*propDatatable*/
    1) {
      $: {
        $$invalidate(0, propDatatable.numberFirstRow = (propDatatable.numberActivePage - 1) * propDatatable.numberRowsPerPage, propDatatable);
        $$invalidate(0, propDatatable.numberLastRow = propDatatable.numberActivePage * propDatatable.numberRowsPerPage, propDatatable);
        $$invalidate(0, propDatatable.arrayData = propDatatable.arraySearched.slice(propDatatable.numberFirstRow, propDatatable.numberLastRow), propDatatable);
      }
    }
  };
  return [propDatatable];
}
var Engine = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { propDatatable: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Engine",
      options,
      id: create_fragment.name
    });
  }
  get propDatatable() {
    throw new Error("<Engine>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set propDatatable(value) {
    throw new Error("<Engine>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Engine_default = Engine;

// node_modules/svelte-datatables-net/dist/functionCreateDatatable.js
var functionCreateDatatable = function({ parData, parSearchableColumns = void 0, parSearchString = "", parRowsPerPage = "all", parSortBy, parSortOrder = "ascending", parSortFunction }) {
  if (parSortFunction === void 0) {
    const sortModifier = parSortOrder === "ascending" ? 1 : -1;
    const functionDefaultSortFunction = function(elementA, elementB) {
      if (parSortBy === void 0) {
        return 0;
      }
      if (elementA[parSortBy] < elementB[parSortBy]) {
        return -1 * sortModifier;
      }
      if (elementA[parSortBy] > elementB[parSortBy]) {
        return 1 * sortModifier;
      }
      return 0;
    };
    parSortFunction = functionDefaultSortFunction;
  }
  const objectSorted = parData.sort(parSortFunction);
  const objectSearched = functionSearch(objectSorted, parSearchString, parSearchableColumns);
  const numberRowsPerPage = parRowsPerPage === "all" ? objectSearched.length : parseInt(parRowsPerPage);
  return {
    arrayRawData: parData,
    arraySorted: objectSorted,
    arraySearched: objectSearched,
    arrayData: objectSearched.slice(0, numberRowsPerPage),
    stringSortBy: parSortBy,
    stringRowsPerPage: parRowsPerPage,
    numberRowsPerPage,
    numberActivePage: 1,
    numberFirstRow: 0,
    numberLastRow: numberRowsPerPage,
    stringSearchString: parSearchString,
    arraySearchableColumns: parSearchableColumns,
    stringSortOrder: parSortOrder,
    functionSort: parSortFunction
  };
};

// node_modules/pagination-svelte/dist/Pagination.svelte
var file = "node_modules/pagination-svelte/dist/Pagination.svelte";
function add_css(target) {
  append_styles(target, "svelte-1b83kv6", ".main.svelte-1b83kv6.svelte-1b83kv6{--bs-font-sans-serif:system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue',\r\n			'Noto Sans', 'Liberation Sans', Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji',\r\n			'Segoe UI Symbol', 'Noto Color Emoji';--bs-body-font-family:var(--bs-font-sans-serif);--bs-secondary-bg:#e9ecef;font-family:var(--bs-body-font-family);line-height:1.5}ul.svelte-1b83kv6.svelte-1b83kv6{margin-top:0;margin-bottom:0}.pagination.svelte-1b83kv6.svelte-1b83kv6{--bs-pagination-padding-x:0.75rem;--bs-pagination-padding-y:0.375rem;--bs-pagination-font-size:1rem;--bs-pagination-color:var(--cssFontColor);--bs-pagination-bg:var(--cssBackgroundColor);--bs-pagination-border-width:var(--cssBorderWidth);--bs-pagination-border-color:var(--cssBorderColor);--bs-pagination-border-radius:0.375rem;--bs-pagination-hover-color:var(--cssHoverFontColor);--bs-pagination-hover-bg:var(--cssHoverBackgroundColor);--bs-pagination-hover-border-color:var(--cssBorderColor);--bs-pagination-focus-color:var(--cssHoverFontColor);--bs-pagination-focus-bg:var(--bs-secondary-bg);--bs-pagination-focus-box-shadow:0 0 0 0.25rem rgba(13, 110, 253, 0.25);--bs-pagination-active-color:var(--cssActiveFontColor);--bs-pagination-active-bg:var(--cssActiveBackgroundColor);--bs-pagination-active-border-color:var(--cssActiveBorderColor);--bs-pagination-disabled-bg:var(--bs-secondary-bg);--bs-pagination-disabled-border-color:var(--cssBorderColor);display:flex;padding-left:0;list-style:none}.page-link.svelte-1b83kv6.svelte-1b83kv6{position:relative;display:block;padding:var(--bs-pagination-padding-y) var(--bs-pagination-padding-x);font-size:var(--bs-pagination-font-size);color:var(--bs-pagination-color);text-decoration:none;background-color:var(--bs-pagination-bg);border:var(--bs-pagination-border-width) solid var(--bs-pagination-border-color);transition:color 0.15s ease-in-out, background-color 0.15s ease-in-out,\r\n			border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out}@media(prefers-reduced-motion: reduce){.page-link.svelte-1b83kv6.svelte-1b83kv6{transition:none}}.page-link.svelte-1b83kv6.svelte-1b83kv6:hover{z-index:2;color:var(--bs-pagination-hover-color);background-color:var(--bs-pagination-hover-bg);border-color:var(--bs-pagination-hover-border-color)}.page-link.svelte-1b83kv6.svelte-1b83kv6:focus{z-index:3;color:var(--bs-pagination-focus-color);background-color:var(--bs-pagination-focus-bg);outline:0;box-shadow:var(--bs-pagination-focus-box-shadow)}.active.svelte-1b83kv6>.page-link.svelte-1b83kv6{z-index:3;color:var(--bs-pagination-active-color);background-color:var(--bs-pagination-active-bg);border-color:var(--bs-pagination-active-border-color)}.disabled.svelte-1b83kv6>.page-link.svelte-1b83kv6{color:var(--cssDisabledColor);pointer-events:none;background-color:var(--bs-pagination-disabled-bg);border-color:var(--bs-pagination-disabled-border-color)}.page-item.svelte-1b83kv6:not(:first-child) .page-link.svelte-1b83kv6{margin-left:calc(var(--cssBorderWidth) * -1)}.page-item.svelte-1b83kv6:first-child .page-link.svelte-1b83kv6{border-top-left-radius:var(--bs-pagination-border-radius);border-bottom-left-radius:var(--bs-pagination-border-radius)}.page-item.svelte-1b83kv6:last-child .page-link.svelte-1b83kv6{border-top-right-radius:var(--bs-pagination-border-radius);border-bottom-right-radius:var(--bs-pagination-border-radius)}.pagination-lg.svelte-1b83kv6.svelte-1b83kv6{--bs-pagination-padding-x:1.5rem;--bs-pagination-padding-y:0.75rem;--bs-pagination-font-size:1.25rem;--bs-pagination-border-radius:0.5rem}.pagination-sm.svelte-1b83kv6.svelte-1b83kv6{--bs-pagination-padding-x:0.5rem;--bs-pagination-padding-y:0.25rem;--bs-pagination-font-size:0.875rem;--bs-pagination-border-radius:0.25rem}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,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 */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[20] = list[i];
  child_ctx[22] = i;
  return child_ctx;
}
function create_else_block_1(ctx) {
  let li;
  let span;
  let t;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      li = element("li");
      span = element("span");
      t = text(
        /*propPrevious*/
        ctx[2]
      );
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true, style: true });
      var li_nodes = children(li);
      span = claim_element(li_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*propPrevious*/
        ctx[2]
      );
      span_nodes.forEach(detach_dev);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "page-link svelte-1b83kv6");
      add_location(span, file, 58, 5, 1952);
      attr_dev(li, "class", "page-item svelte-1b83kv6");
      set_style(li, "cursor", "pointer");
      add_location(li, file, 48, 4, 1719);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, span);
      append_hydration_dev(span, t);
      if (!mounted) {
        dispose = listen_dev(
          li,
          "click",
          /*click_handler_1*/
          ctx[17],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*propPrevious*/
      4)
        set_data_dev(
          t,
          /*propPrevious*/
          ctx2[2]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(47:3) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let li;
  let span;
  let t;
  const block = {
    c: function create() {
      li = element("li");
      span = element("span");
      t = text(
        /*propPrevious*/
        ctx[2]
      );
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true, style: true });
      var li_nodes = children(li);
      span = claim_element(li_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*propPrevious*/
        ctx[2]
      );
      span_nodes.forEach(detach_dev);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "page-link svelte-1b83kv6");
      add_location(span, file, 44, 5, 1583);
      attr_dev(li, "class", "page-item disabled svelte-1b83kv6");
      set_style(li, "cursor", "not-allowed");
      add_location(li, file, 43, 4, 1518);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, span);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*propPrevious*/
      4)
        set_data_dev(
          t,
          /*propPrevious*/
          ctx2[2]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(43:3) {#if propActivePage === 1}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let li;
  let span;
  let t_value = (
    /*numberCounter*/
    ctx[22] + 1 + ""
  );
  let t;
  let mounted;
  let dispose;
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[18](
        /*numberCounter*/
        ctx[22]
      )
    );
  }
  const block = {
    c: function create() {
      li = element("li");
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      span = claim_element(li_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "page-link svelte-1b83kv6");
      add_location(span, file, 75, 5, 2487);
      attr_dev(li, "class", "page-item svelte-1b83kv6");
      toggle_class(
        li,
        "active",
        /*numberCounter*/
        ctx[22] + 1 === /*propActivePage*/
        ctx[0]
      );
      set_style(
        li,
        "cursor",
        /*propActivePage*/
        ctx[0] === /*numberCounter*/
        ctx[22] + 1 ? "default" : "pointer"
      );
      add_location(li, file, 64, 4, 2145);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, span);
      append_hydration_dev(span, t);
      if (!mounted) {
        dispose = listen_dev(li, "click", click_handler_2, false, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*propActivePage*/
      1) {
        toggle_class(
          li,
          "active",
          /*numberCounter*/
          ctx[22] + 1 === /*propActivePage*/
          ctx[0]
        );
      }
      if (dirty & /*propActivePage*/
      1) {
        set_style(
          li,
          "cursor",
          /*propActivePage*/
          ctx[0] === /*numberCounter*/
          ctx[22] + 1 ? "default" : "pointer"
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(63:3) {#each Array(propNumberOfPages) as _, numberCounter}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let li;
  let span;
  let t;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      li = element("li");
      span = element("span");
      t = text(
        /*propNext*/
        ctx[3]
      );
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true, style: true });
      var li_nodes = children(li);
      span = claim_element(li_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*propNext*/
        ctx[3]
      );
      span_nodes.forEach(detach_dev);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "page-link svelte-1b83kv6");
      add_location(span, file, 94, 5, 3043);
      attr_dev(li, "class", "page-item svelte-1b83kv6");
      set_style(li, "cursor", "pointer");
      add_location(li, file, 84, 4, 2811);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, span);
      append_hydration_dev(span, t);
      if (!mounted) {
        dispose = listen_dev(
          li,
          "click",
          /*click_handler_3*/
          ctx[19],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*propNext*/
      8)
        set_data_dev(
          t,
          /*propNext*/
          ctx2[3]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(83:3) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let li;
  let span;
  let t;
  const block = {
    c: function create() {
      li = element("li");
      span = element("span");
      t = text(
        /*propNext*/
        ctx[3]
      );
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true, style: true });
      var li_nodes = children(li);
      span = claim_element(li_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*propNext*/
        ctx[3]
      );
      span_nodes.forEach(detach_dev);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "page-link svelte-1b83kv6");
      add_location(span, file, 80, 5, 2679);
      attr_dev(li, "class", "page-item disabled svelte-1b83kv6");
      set_style(li, "cursor", "not-allowed");
      add_location(li, file, 79, 4, 2613);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, span);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*propNext*/
      8)
        set_data_dev(
          t,
          /*propNext*/
          ctx2[3]
        );
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(li);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(79:3) {#if propActivePage === propNumberOfPages}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div;
  let nav;
  let ul;
  let t0;
  let t1;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*propActivePage*/
      ctx2[0] === 1
    )
      return create_if_block_1;
    return create_else_block_1;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block0 = current_block_type(ctx);
  let each_value = Array(
    /*propNumberOfPages*/
    ctx[1]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  function select_block_type_1(ctx2, dirty) {
    if (
      /*propActivePage*/
      ctx2[0] === /*propNumberOfPages*/
      ctx2[1]
    )
      return create_if_block;
    return create_else_block;
  }
  let current_block_type_1 = select_block_type_1(ctx, -1);
  let if_block1 = current_block_type_1(ctx);
  const block = {
    c: function create() {
      div = element("div");
      nav = element("nav");
      ul = element("ul");
      if_block0.c();
      t0 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      nav = claim_element(div_nodes, "NAV", { style: true });
      var nav_nodes = children(nav);
      ul = claim_element(nav_nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      if_block0.l(ul_nodes);
      t0 = claim_space(ul_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      t1 = claim_space(ul_nodes);
      if_block1.l(ul_nodes);
      ul_nodes.forEach(detach_dev);
      nav_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "class", "pagination svelte-1b83kv6");
      toggle_class(
        ul,
        "pagination-sm",
        /*propSize*/
        ctx[4] === "small"
      );
      toggle_class(
        ul,
        "pagination-lg",
        /*propSize*/
        ctx[4] === "large"
      );
      add_location(ul, file, 37, 2, 1356);
      set_style(nav, "overflow-x", "auto");
      set_style(nav, "-webkit-overflow-scrolling", "touch");
      add_location(nav, file, 36, 1, 1277);
      attr_dev(div, "class", "main svelte-1b83kv6");
      set_style(div, "display", "flex");
      set_style(
        div,
        "--cssActiveBackgroundColor",
        /*cssActiveBackgroundColor*/
        ctx[5]
      );
      set_style(
        div,
        "--cssActiveFontColor",
        /*cssActiveFontColor*/
        ctx[8]
      );
      set_style(
        div,
        "--cssActiveBorderColor",
        /*cssActiveBorderColor*/
        ctx[7]
      );
      set_style(
        div,
        "--cssHoverBackgroundColor",
        /*cssHoverBackgroundColor*/
        ctx[9]
      );
      set_style(
        div,
        "--cssFontColor",
        /*cssFontColor*/
        ctx[10]
      );
      set_style(
        div,
        "--cssBackgroundColor",
        /*cssBackgroundColor*/
        ctx[6]
      );
      set_style(
        div,
        "--cssHoverFontColor",
        /*cssHoverFontColor*/
        ctx[11]
      );
      set_style(
        div,
        "--cssBorderWidth",
        /*cssBorderWidth*/
        ctx[12]
      );
      set_style(
        div,
        "--cssDisabledColor",
        /*cssDisabledColor*/
        ctx[13]
      );
      set_style(
        div,
        "--cssBorderColor",
        /*cssBorderColor*/
        ctx[14]
      );
      add_location(div, file, 19, 0, 709);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, nav);
      append_hydration_dev(nav, ul);
      if_block0.m(ul, null);
      append_hydration_dev(ul, t0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      append_hydration_dev(ul, t1);
      if_block1.m(ul, null);
      if (!mounted) {
        dispose = listen_dev(
          nav,
          "click",
          /*click_handler*/
          ctx[16],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(ul, t0);
        }
      }
      if (dirty & /*propActivePage, dispatch, propNumberOfPages*/
      32771) {
        each_value = Array(
          /*propNumberOfPages*/
          ctx2[1]
        );
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, t1);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx2, dirty)) && if_block1) {
        if_block1.p(ctx2, dirty);
      } else {
        if_block1.d(1);
        if_block1 = current_block_type_1(ctx2);
        if (if_block1) {
          if_block1.c();
          if_block1.m(ul, null);
        }
      }
      if (dirty & /*propSize*/
      16) {
        toggle_class(
          ul,
          "pagination-sm",
          /*propSize*/
          ctx2[4] === "small"
        );
      }
      if (dirty & /*propSize*/
      16) {
        toggle_class(
          ul,
          "pagination-lg",
          /*propSize*/
          ctx2[4] === "large"
        );
      }
      if (dirty & /*cssActiveBackgroundColor*/
      32) {
        set_style(
          div,
          "--cssActiveBackgroundColor",
          /*cssActiveBackgroundColor*/
          ctx2[5]
        );
      }
      if (dirty & /*cssActiveFontColor*/
      256) {
        set_style(
          div,
          "--cssActiveFontColor",
          /*cssActiveFontColor*/
          ctx2[8]
        );
      }
      if (dirty & /*cssActiveBorderColor*/
      128) {
        set_style(
          div,
          "--cssActiveBorderColor",
          /*cssActiveBorderColor*/
          ctx2[7]
        );
      }
      if (dirty & /*cssHoverBackgroundColor*/
      512) {
        set_style(
          div,
          "--cssHoverBackgroundColor",
          /*cssHoverBackgroundColor*/
          ctx2[9]
        );
      }
      if (dirty & /*cssFontColor*/
      1024) {
        set_style(
          div,
          "--cssFontColor",
          /*cssFontColor*/
          ctx2[10]
        );
      }
      if (dirty & /*cssBackgroundColor*/
      64) {
        set_style(
          div,
          "--cssBackgroundColor",
          /*cssBackgroundColor*/
          ctx2[6]
        );
      }
      if (dirty & /*cssHoverFontColor*/
      2048) {
        set_style(
          div,
          "--cssHoverFontColor",
          /*cssHoverFontColor*/
          ctx2[11]
        );
      }
      if (dirty & /*cssBorderWidth*/
      4096) {
        set_style(
          div,
          "--cssBorderWidth",
          /*cssBorderWidth*/
          ctx2[12]
        );
      }
      if (dirty & /*cssDisabledColor*/
      8192) {
        set_style(
          div,
          "--cssDisabledColor",
          /*cssDisabledColor*/
          ctx2[13]
        );
      }
      if (dirty & /*cssBorderColor*/
      16384) {
        set_style(
          div,
          "--cssBorderColor",
          /*cssBorderColor*/
          ctx2[14]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_block0.d();
      destroy_each(each_blocks, detaching);
      if_block1.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Pagination", slots, []);
  const dispatch = createEventDispatcher();
  let { propActivePage = 1 } = $$props;
  let { propNumberOfPages = 5 } = $$props;
  let { propPrevious = "PREVIOUS" } = $$props;
  let { propNext = "NEXT" } = $$props;
  let { propSize = "default" } = $$props;
  let { cssActiveBackgroundColor = "#0d6efd" } = $$props;
  let { cssBackgroundColor = "#fff" } = $$props;
  let { cssActiveBorderColor = "#0d6efd" } = $$props;
  let { cssActiveFontColor = "white" } = $$props;
  let { cssHoverBackgroundColor = "#f8f9fa" } = $$props;
  let { cssFontColor = "#0d6efd" } = $$props;
  let { cssHoverFontColor = "#0a58ca" } = $$props;
  let { cssBorderWidth = "1px" } = $$props;
  let { cssDisabledColor = "rgba(33, 37, 41, 0.75)" } = $$props;
  let { cssBorderColor = "#dee2e6" } = $$props;
  const writable_props = [
    "propActivePage",
    "propNumberOfPages",
    "propPrevious",
    "propNext",
    "propSize",
    "cssActiveBackgroundColor",
    "cssBackgroundColor",
    "cssActiveBorderColor",
    "cssActiveFontColor",
    "cssHoverBackgroundColor",
    "cssFontColor",
    "cssHoverFontColor",
    "cssBorderWidth",
    "cssDisabledColor",
    "cssBorderColor"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Pagination> was created with unknown prop '${key}'`);
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  const click_handler_1 = () => {
    $$invalidate(0, propActivePage = propActivePage - 1);
    dispatch("eventChange", { numberActivePage: propActivePage });
  };
  const click_handler_2 = (numberCounter) => {
    $$invalidate(0, propActivePage = numberCounter + 1);
    dispatch("eventChange", { numberActivePage: propActivePage });
  };
  const click_handler_3 = () => {
    $$invalidate(0, propActivePage = propActivePage + 1);
    dispatch("eventChange", { numberActivePage: propActivePage });
  };
  $$self.$$set = ($$props2) => {
    if ("propActivePage" in $$props2)
      $$invalidate(0, propActivePage = $$props2.propActivePage);
    if ("propNumberOfPages" in $$props2)
      $$invalidate(1, propNumberOfPages = $$props2.propNumberOfPages);
    if ("propPrevious" in $$props2)
      $$invalidate(2, propPrevious = $$props2.propPrevious);
    if ("propNext" in $$props2)
      $$invalidate(3, propNext = $$props2.propNext);
    if ("propSize" in $$props2)
      $$invalidate(4, propSize = $$props2.propSize);
    if ("cssActiveBackgroundColor" in $$props2)
      $$invalidate(5, cssActiveBackgroundColor = $$props2.cssActiveBackgroundColor);
    if ("cssBackgroundColor" in $$props2)
      $$invalidate(6, cssBackgroundColor = $$props2.cssBackgroundColor);
    if ("cssActiveBorderColor" in $$props2)
      $$invalidate(7, cssActiveBorderColor = $$props2.cssActiveBorderColor);
    if ("cssActiveFontColor" in $$props2)
      $$invalidate(8, cssActiveFontColor = $$props2.cssActiveFontColor);
    if ("cssHoverBackgroundColor" in $$props2)
      $$invalidate(9, cssHoverBackgroundColor = $$props2.cssHoverBackgroundColor);
    if ("cssFontColor" in $$props2)
      $$invalidate(10, cssFontColor = $$props2.cssFontColor);
    if ("cssHoverFontColor" in $$props2)
      $$invalidate(11, cssHoverFontColor = $$props2.cssHoverFontColor);
    if ("cssBorderWidth" in $$props2)
      $$invalidate(12, cssBorderWidth = $$props2.cssBorderWidth);
    if ("cssDisabledColor" in $$props2)
      $$invalidate(13, cssDisabledColor = $$props2.cssDisabledColor);
    if ("cssBorderColor" in $$props2)
      $$invalidate(14, cssBorderColor = $$props2.cssBorderColor);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    dispatch,
    propActivePage,
    propNumberOfPages,
    propPrevious,
    propNext,
    propSize,
    cssActiveBackgroundColor,
    cssBackgroundColor,
    cssActiveBorderColor,
    cssActiveFontColor,
    cssHoverBackgroundColor,
    cssFontColor,
    cssHoverFontColor,
    cssBorderWidth,
    cssDisabledColor,
    cssBorderColor
  });
  $$self.$inject_state = ($$props2) => {
    if ("propActivePage" in $$props2)
      $$invalidate(0, propActivePage = $$props2.propActivePage);
    if ("propNumberOfPages" in $$props2)
      $$invalidate(1, propNumberOfPages = $$props2.propNumberOfPages);
    if ("propPrevious" in $$props2)
      $$invalidate(2, propPrevious = $$props2.propPrevious);
    if ("propNext" in $$props2)
      $$invalidate(3, propNext = $$props2.propNext);
    if ("propSize" in $$props2)
      $$invalidate(4, propSize = $$props2.propSize);
    if ("cssActiveBackgroundColor" in $$props2)
      $$invalidate(5, cssActiveBackgroundColor = $$props2.cssActiveBackgroundColor);
    if ("cssBackgroundColor" in $$props2)
      $$invalidate(6, cssBackgroundColor = $$props2.cssBackgroundColor);
    if ("cssActiveBorderColor" in $$props2)
      $$invalidate(7, cssActiveBorderColor = $$props2.cssActiveBorderColor);
    if ("cssActiveFontColor" in $$props2)
      $$invalidate(8, cssActiveFontColor = $$props2.cssActiveFontColor);
    if ("cssHoverBackgroundColor" in $$props2)
      $$invalidate(9, cssHoverBackgroundColor = $$props2.cssHoverBackgroundColor);
    if ("cssFontColor" in $$props2)
      $$invalidate(10, cssFontColor = $$props2.cssFontColor);
    if ("cssHoverFontColor" in $$props2)
      $$invalidate(11, cssHoverFontColor = $$props2.cssHoverFontColor);
    if ("cssBorderWidth" in $$props2)
      $$invalidate(12, cssBorderWidth = $$props2.cssBorderWidth);
    if ("cssDisabledColor" in $$props2)
      $$invalidate(13, cssDisabledColor = $$props2.cssDisabledColor);
    if ("cssBorderColor" in $$props2)
      $$invalidate(14, cssBorderColor = $$props2.cssBorderColor);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    propActivePage,
    propNumberOfPages,
    propPrevious,
    propNext,
    propSize,
    cssActiveBackgroundColor,
    cssBackgroundColor,
    cssActiveBorderColor,
    cssActiveFontColor,
    cssHoverBackgroundColor,
    cssFontColor,
    cssHoverFontColor,
    cssBorderWidth,
    cssDisabledColor,
    cssBorderColor,
    dispatch,
    click_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3
  ];
}
var Pagination = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        propActivePage: 0,
        propNumberOfPages: 1,
        propPrevious: 2,
        propNext: 3,
        propSize: 4,
        cssActiveBackgroundColor: 5,
        cssBackgroundColor: 6,
        cssActiveBorderColor: 7,
        cssActiveFontColor: 8,
        cssHoverBackgroundColor: 9,
        cssFontColor: 10,
        cssHoverFontColor: 11,
        cssBorderWidth: 12,
        cssDisabledColor: 13,
        cssBorderColor: 14
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pagination",
      options,
      id: create_fragment2.name
    });
  }
  get propActivePage() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set propActivePage(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get propNumberOfPages() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set propNumberOfPages(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get propPrevious() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set propPrevious(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get propNext() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set propNext(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get propSize() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set propSize(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cssActiveBackgroundColor() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cssActiveBackgroundColor(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cssBackgroundColor() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cssBackgroundColor(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cssActiveBorderColor() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cssActiveBorderColor(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cssActiveFontColor() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cssActiveFontColor(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cssHoverBackgroundColor() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cssHoverBackgroundColor(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cssFontColor() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cssFontColor(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cssHoverFontColor() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cssHoverFontColor(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cssBorderWidth() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cssBorderWidth(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cssDisabledColor() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cssDisabledColor(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cssBorderColor() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cssBorderColor(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Pagination_default = Pagination;

// node_modules/pagination-svelte/dist/index.js
var dist_default = Pagination_default;

// node_modules/svelte-datatables-net/dist/Pagination.svelte
function create_fragment3(ctx) {
  let pagination;
  let updating_propActivePage;
  let current;
  const pagination_spread_levels = [
    {
      propNumberOfPages: (
        /*propDatatable*/
        ctx[0].numberRowsPerPage === Infinity ? 1 : Math.ceil(
          /*propDatatable*/
          ctx[0].arraySearched.length / /*propDatatable*/
          ctx[0].numberRowsPerPage
        )
      )
    },
    /*objectOtherProps*/
    ctx[1]
  ];
  function pagination_propActivePage_binding(value) {
    ctx[2](value);
  }
  let pagination_props = {};
  for (let i = 0; i < pagination_spread_levels.length; i += 1) {
    pagination_props = assign(pagination_props, pagination_spread_levels[i]);
  }
  if (
    /*propDatatable*/
    ctx[0].numberActivePage !== void 0
  ) {
    pagination_props.propActivePage = /*propDatatable*/
    ctx[0].numberActivePage;
  }
  pagination = new dist_default({ props: pagination_props, $$inline: true });
  binding_callbacks.push(() => bind(pagination, "propActivePage", pagination_propActivePage_binding));
  const block = {
    c: function create() {
      create_component(pagination.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(pagination.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(pagination, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const pagination_changes = dirty & /*propDatatable, Infinity, Math, objectOtherProps*/
      3 ? get_spread_update(pagination_spread_levels, [
        dirty & /*propDatatable, Infinity, Math*/
        1 && {
          propNumberOfPages: (
            /*propDatatable*/
            ctx2[0].numberRowsPerPage === Infinity ? 1 : Math.ceil(
              /*propDatatable*/
              ctx2[0].arraySearched.length / /*propDatatable*/
              ctx2[0].numberRowsPerPage
            )
          )
        },
        dirty & /*objectOtherProps*/
        2 && get_spread_object(
          /*objectOtherProps*/
          ctx2[1]
        )
      ]) : {};
      if (!updating_propActivePage && dirty & /*propDatatable*/
      1) {
        updating_propActivePage = true;
        pagination_changes.propActivePage = /*propDatatable*/
        ctx2[0].numberActivePage;
        add_flush_callback(() => updating_propActivePage = false);
      }
      pagination.$set(pagination_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(pagination.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(pagination.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(pagination, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Pagination", slots, []);
  let { propDatatable } = $$props;
  let { propDatatable: _, ...objectOtherProps } = $$props;
  $$self.$$.on_mount.push(function() {
    if (propDatatable === void 0 && !("propDatatable" in $$props || $$self.$$.bound[$$self.$$.props["propDatatable"]])) {
      console.warn("<Pagination> was created without expected prop 'propDatatable'");
    }
  });
  function pagination_propActivePage_binding(value) {
    if ($$self.$$.not_equal(propDatatable.numberActivePage, value)) {
      propDatatable.numberActivePage = value;
      $$invalidate(0, propDatatable);
    }
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("propDatatable" in $$new_props)
      $$invalidate(0, propDatatable = $$new_props.propDatatable);
  };
  $$self.$capture_state = () => ({
    Pagination: dist_default,
    propDatatable,
    _,
    objectOtherProps
  });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
    if ("propDatatable" in $$props)
      $$invalidate(0, propDatatable = $$new_props.propDatatable);
    if ("_" in $$props)
      _ = $$new_props._;
    if ("objectOtherProps" in $$props)
      $$invalidate(1, objectOtherProps = $$new_props.objectOtherProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [propDatatable, objectOtherProps, pagination_propActivePage_binding];
}
var Pagination_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { propDatatable: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pagination_1",
      options,
      id: create_fragment3.name
    });
  }
  get propDatatable() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set propDatatable(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Pagination_default2 = Pagination_1;

// node_modules/svelte-datatables-net/dist/RowsPerPage.svelte
var file2 = "node_modules/svelte-datatables-net/dist/RowsPerPage.svelte";
function create_fragment4(ctx) {
  let select;
  let select_style_value;
  let select_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  const block = {
    c: function create() {
      select = element("select");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      select = claim_element(nodes, "SELECT", { style: true, class: true });
      var select_nodes = children(select);
      if (default_slot)
        default_slot.l(select_nodes);
      select_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(select, "style", select_style_value = /*$$props*/
      ctx[2].style);
      attr_dev(select, "class", select_class_value = /*$$props*/
      ctx[2].class);
      if (
        /*propDatatable*/
        ctx[0].stringRowsPerPage === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[5].call(select)
        ));
      add_location(select, file2, 7, 0, 258);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, select, anchor);
      if (default_slot) {
        default_slot.m(select, null);
      }
      select_option(
        select,
        /*propDatatable*/
        ctx[0].stringRowsPerPage,
        true
      );
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            select,
            "change",
            /*select_change_handler*/
            ctx[5]
          ),
          listen_dev(
            select,
            "change",
            /*functionChange*/
            ctx[1],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$$props*/
      4 && select_style_value !== (select_style_value = /*$$props*/
      ctx2[2].style)) {
        attr_dev(select, "style", select_style_value);
      }
      if (!current || dirty & /*$$props*/
      4 && select_class_value !== (select_class_value = /*$$props*/
      ctx2[2].class)) {
        attr_dev(select, "class", select_class_value);
      }
      if (dirty & /*propDatatable*/
      1) {
        select_option(
          select,
          /*propDatatable*/
          ctx2[0].stringRowsPerPage
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(select);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RowsPerPage", slots, ["default"]);
  let { propDatatable } = $$props;
  const functionChange = function() {
    $$invalidate(
      0,
      propDatatable.numberRowsPerPage = propDatatable.stringRowsPerPage === "all" ? Infinity : parseInt(propDatatable.stringRowsPerPage),
      propDatatable
    );
    $$invalidate(0, propDatatable.numberActivePage = 1, propDatatable);
  };
  $$self.$$.on_mount.push(function() {
    if (propDatatable === void 0 && !("propDatatable" in $$props || $$self.$$.bound[$$self.$$.props["propDatatable"]])) {
      console.warn("<RowsPerPage> was created without expected prop 'propDatatable'");
    }
  });
  function select_change_handler() {
    propDatatable.stringRowsPerPage = select_value(this);
    $$invalidate(0, propDatatable);
  }
  $$self.$$set = ($$new_props) => {
    $$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("propDatatable" in $$new_props)
      $$invalidate(0, propDatatable = $$new_props.propDatatable);
    if ("$$scope" in $$new_props)
      $$invalidate(3, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({ propDatatable, functionChange });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
    if ("propDatatable" in $$props)
      $$invalidate(0, propDatatable = $$new_props.propDatatable);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [propDatatable, functionChange, $$props, $$scope, slots, select_change_handler];
}
var RowsPerPage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { propDatatable: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RowsPerPage",
      options,
      id: create_fragment4.name
    });
  }
  get propDatatable() {
    throw new Error("<RowsPerPage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set propDatatable(value) {
    throw new Error("<RowsPerPage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RowsPerPage_default = RowsPerPage;

// node_modules/svelte-datatables-net/dist/Search.svelte
var file3 = "node_modules/svelte-datatables-net/dist/Search.svelte";
function create_fragment5(ctx) {
  let input;
  let input_style_value;
  let input_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        type: true,
        placeholder: true,
        style: true,
        class: true
      });
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "search");
      attr_dev(
        input,
        "placeholder",
        /*propPlaceholder*/
        ctx[1]
      );
      attr_dev(input, "style", input_style_value = /*$$props*/
      ctx[2].style);
      attr_dev(input, "class", input_class_value = /*$$props*/
      ctx[2].class);
      add_location(input, file3, 4, 0, 92);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      set_input_value(
        input,
        /*propDatatable*/
        ctx[0].stringSearchString
      );
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[3]
          ),
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[4],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*propPlaceholder*/
      2) {
        attr_dev(
          input,
          "placeholder",
          /*propPlaceholder*/
          ctx2[1]
        );
      }
      if (dirty & /*$$props*/
      4 && input_style_value !== (input_style_value = /*$$props*/
      ctx2[2].style)) {
        attr_dev(input, "style", input_style_value);
      }
      if (dirty & /*$$props*/
      4 && input_class_value !== (input_class_value = /*$$props*/
      ctx2[2].class)) {
        attr_dev(input, "class", input_class_value);
      }
      if (dirty & /*propDatatable*/
      1 && input.value !== /*propDatatable*/
      ctx2[0].stringSearchString) {
        set_input_value(
          input,
          /*propDatatable*/
          ctx2[0].stringSearchString
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Search", slots, []);
  let { propDatatable } = $$props;
  let { propPlaceholder = "Type here..." } = $$props;
  $$self.$$.on_mount.push(function() {
    if (propDatatable === void 0 && !("propDatatable" in $$props || $$self.$$.bound[$$self.$$.props["propDatatable"]])) {
      console.warn("<Search> was created without expected prop 'propDatatable'");
    }
  });
  function input_input_handler() {
    propDatatable.stringSearchString = this.value;
    $$invalidate(0, propDatatable);
  }
  const input_handler = () => $$invalidate(0, propDatatable.numberActivePage = 1, propDatatable);
  $$self.$$set = ($$new_props) => {
    $$invalidate(2, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    if ("propDatatable" in $$new_props)
      $$invalidate(0, propDatatable = $$new_props.propDatatable);
    if ("propPlaceholder" in $$new_props)
      $$invalidate(1, propPlaceholder = $$new_props.propPlaceholder);
  };
  $$self.$capture_state = () => ({ propDatatable, propPlaceholder });
  $$self.$inject_state = ($$new_props) => {
    $$invalidate(2, $$props = assign(assign({}, $$props), $$new_props));
    if ("propDatatable" in $$props)
      $$invalidate(0, propDatatable = $$new_props.propDatatable);
    if ("propPlaceholder" in $$props)
      $$invalidate(1, propPlaceholder = $$new_props.propPlaceholder);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$props = exclude_internal_props($$props);
  return [propDatatable, propPlaceholder, $$props, input_input_handler, input_handler];
}
var Search = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { propDatatable: 0, propPlaceholder: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Search",
      options,
      id: create_fragment5.name
    });
  }
  get propDatatable() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set propDatatable(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get propPlaceholder() {
    throw new Error("<Search>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set propPlaceholder(value) {
    throw new Error("<Search>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Search_default = Search;

// node_modules/svelte-datatables-net/dist/Sort.svelte
var file4 = "node_modules/svelte-datatables-net/dist/Sort.svelte";
function create_else_block_12(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        style: true,
        xmlns: true,
        viewBox: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M137.4 41.4c12.5-12.5 32.8-12.5 45.3 0l128 128c9.2 9.2 11.9 22.9 6.9 34.9s-16.6 19.8-29.6 19.8H32c-12.9 0-24.6-7.8-29.6-19.8s-2.2-25.7 6.9-34.9l128-128zm0 429.3l-128-128c-9.2-9.2-11.9-22.9-6.9-34.9s16.6-19.8 29.6-19.8H288c12.9 0 24.6 7.8 29.6 19.8s2.2 25.7-6.9 34.9l-128 128c-12.5 12.5-32.8 12.5-45.3 0z");
      add_location(path, file4, 50, 3, 1889);
      attr_dev(
        svg,
        "width",
        /*propIconSize*/
        ctx[2]
      );
      set_style(svg, "fill", "lightgray");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 320 512");
      add_location(svg, file4, 44, 2, 1757);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*propIconSize*/
      4) {
        attr_dev(
          svg,
          "width",
          /*propIconSize*/
          ctx2[2]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_12.name,
    type: "else",
    source: "(44:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*propDatatable*/
      ctx2[0].stringSortOrder === "ascending"
    )
      return create_if_block_12;
    return create_else_block2;
  }
  let current_block_type = select_block_type_1(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(28:1) {#if propDatatable.stringSortBy === propColumn}",
    ctx
  });
  return block;
}
function create_else_block2(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { width: true, xmlns: true, viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M182.6 137.4c-12.5-12.5-32.8-12.5-45.3 0l-128 128c-9.2 9.2-11.9 22.9-6.9 34.9s16.6 19.8 29.6 19.8H288c12.9 0 24.6-7.8 29.6-19.8s2.2-25.7-6.9-34.9l-128-128z");
      add_location(path, file4, 38, 4, 1544);
      attr_dev(
        svg,
        "width",
        /*propIconSize*/
        ctx[2]
      );
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 320 512");
      add_location(svg, file4, 37, 3, 1455);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*propIconSize*/
      4) {
        attr_dev(
          svg,
          "width",
          /*propIconSize*/
          ctx2[2]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(36:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", { width: true, xmlns: true, viewBox: true });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M137.4 374.6c12.5 12.5 32.8 12.5 45.3 0l128-128c9.2-9.2 11.9-22.9 6.9-34.9s-16.6-19.8-29.6-19.8L32 192c-12.9 0-24.6 7.8-29.6 19.8s-2.2 25.7 6.9 34.9l128 128z");
      add_location(path, file4, 31, 4, 1199);
      attr_dev(
        svg,
        "width",
        /*propIconSize*/
        ctx[2]
      );
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 320 512");
      add_location(svg, file4, 30, 3, 1110);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*propIconSize*/
      4) {
        attr_dev(
          svg,
          "width",
          /*propIconSize*/
          ctx2[2]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(29:2) {#if propDatatable.stringSortOrder === 'ascending'}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let span;
  let t;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[6].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  function select_block_type(ctx2, dirty) {
    if (
      /*propDatatable*/
      ctx2[0].stringSortBy === /*propColumn*/
      ctx2[1]
    )
      return create_if_block2;
    return create_else_block_12;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      t = space();
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { style: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      t = claim_space(span_nodes);
      if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_style(span, "cursor", "pointer");
      set_style(span, "white-space", "nowrap");
      add_location(span, file4, 25, 0, 853);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      append_hydration_dev(span, t);
      if_block.m(span, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          span,
          "click",
          /*functionUpdateSortConfig*/
          ctx[3],
          false,
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(span, null);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot)
        default_slot.d(detaching);
      if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Sort", slots, ["default"]);
  let { propColumn } = $$props;
  let { propDatatable } = $$props;
  let { propIconSize = 10 } = $$props;
  let { propSortFunction = function(elementA, elementB) {
    const sortModifier = propDatatable.stringSortOrder === "ascending" ? 1 : -1;
    if (elementA[propColumn] < elementB[propColumn]) {
      return -1 * sortModifier;
    }
    if (elementA[propColumn] > elementB[propColumn]) {
      return 1 * sortModifier;
    }
    return 0;
  } } = $$props;
  const functionUpdateSortConfig = function() {
    if (propDatatable.stringSortBy === propColumn) {
      $$invalidate(
        0,
        propDatatable.stringSortOrder = propDatatable.stringSortOrder === "ascending" ? "descending" : "ascending",
        propDatatable
      );
      return;
    }
    $$invalidate(0, propDatatable.stringSortBy = propColumn, propDatatable);
    $$invalidate(0, propDatatable.stringSortOrder = "ascending", propDatatable);
    $$invalidate(0, propDatatable.functionSort = propSortFunction, propDatatable);
  };
  $$self.$$.on_mount.push(function() {
    if (propColumn === void 0 && !("propColumn" in $$props || $$self.$$.bound[$$self.$$.props["propColumn"]])) {
      console.warn("<Sort> was created without expected prop 'propColumn'");
    }
    if (propDatatable === void 0 && !("propDatatable" in $$props || $$self.$$.bound[$$self.$$.props["propDatatable"]])) {
      console.warn("<Sort> was created without expected prop 'propDatatable'");
    }
  });
  const writable_props = ["propColumn", "propDatatable", "propIconSize", "propSortFunction"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Sort> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("propColumn" in $$props2)
      $$invalidate(1, propColumn = $$props2.propColumn);
    if ("propDatatable" in $$props2)
      $$invalidate(0, propDatatable = $$props2.propDatatable);
    if ("propIconSize" in $$props2)
      $$invalidate(2, propIconSize = $$props2.propIconSize);
    if ("propSortFunction" in $$props2)
      $$invalidate(4, propSortFunction = $$props2.propSortFunction);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    propColumn,
    propDatatable,
    propIconSize,
    propSortFunction,
    functionUpdateSortConfig
  });
  $$self.$inject_state = ($$props2) => {
    if ("propColumn" in $$props2)
      $$invalidate(1, propColumn = $$props2.propColumn);
    if ("propDatatable" in $$props2)
      $$invalidate(0, propDatatable = $$props2.propDatatable);
    if ("propIconSize" in $$props2)
      $$invalidate(2, propIconSize = $$props2.propIconSize);
    if ("propSortFunction" in $$props2)
      $$invalidate(4, propSortFunction = $$props2.propSortFunction);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    propDatatable,
    propColumn,
    propIconSize,
    functionUpdateSortConfig,
    propSortFunction,
    $$scope,
    slots
  ];
}
var Sort = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, {
      propColumn: 1,
      propDatatable: 0,
      propIconSize: 2,
      propSortFunction: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Sort",
      options,
      id: create_fragment6.name
    });
  }
  get propColumn() {
    throw new Error("<Sort>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set propColumn(value) {
    throw new Error("<Sort>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get propDatatable() {
    throw new Error("<Sort>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set propDatatable(value) {
    throw new Error("<Sort>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get propIconSize() {
    throw new Error("<Sort>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set propIconSize(value) {
    throw new Error("<Sort>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get propSortFunction() {
    throw new Error("<Sort>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set propSortFunction(value) {
    throw new Error("<Sort>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Sort_default = Sort;
export {
  Engine_default as Engine,
  Pagination_default2 as Pagination,
  RowsPerPage_default as RowsPerPage,
  Search_default as Search,
  Sort_default as Sort,
  functionCreateDatatable
};
//# sourceMappingURL=svelte-datatables-net.js.map
